/**
 * Contract Import Command
 *
 * Fetches ABI from block explorers and generates typed LootiScript wrappers
 */

import fs from "fs-extra";
import path from "path";
import pc from "picocolors";
import { DEFAULT_DIRS } from "../utils/paths";

export interface ContractImportOptions {
	/** Contract address */
	address: string;
	/** Chain name (base, ethereum, optimism, arbitrum) */
	chain: string;
	/** Contract name for the generated wrapper */
	name: string;
	/** Project root path */
	projectPath?: string;
	/** API key for block explorer (optional) */
	apiKey?: string;
}

/**
 * Chain configuration for block explorers
 */
const CHAIN_CONFIG: Record<
	string,
	{
		explorer: string;
		apiUrl: string;
	}
> = {
	base: {
		explorer: "Basescan",
		apiUrl: "https://api.basescan.org/api",
	},
	ethereum: {
		explorer: "Etherscan",
		apiUrl: "https://api.etherscan.io/api",
	},
	optimism: {
		explorer: "Optimistic Etherscan",
		apiUrl: "https://api-optimistic.etherscan.io/api",
	},
	arbitrum: {
		explorer: "Arbiscan",
		apiUrl: "https://api.arbiscan.io/api",
	},
};

/**
 * Fetch ABI from block explorer
 */
async function fetchABI(address: string, chain: string, apiKey?: string): Promise<any[]> {
	const config = CHAIN_CONFIG[chain.toLowerCase()];
	if (!config) {
		throw new Error(`Unsupported chain: ${chain}. Supported chains: ${Object.keys(CHAIN_CONFIG).join(", ")}`);
	}

	// Try to get API key from environment if not provided
	const key = apiKey || process.env[`${chain.toUpperCase()}_API_KEY`] || "";

	const url = `${config.apiUrl}?module=contract&action=getabi&address=${address}&apikey=${key}`;

	try {
		const response = await fetch(url);
		const data = await response.json();

		if (data.status === "0" && data.message === "NOTOK") {
			if (data.result === "Max rate limit reached") {
				throw new Error(
					`Rate limit reached. Please provide an API key: ${config.explorer} API key via --api-key or ${chain.toUpperCase()}_API_KEY environment variable`,
				);
			}
			throw new Error(`Failed to fetch ABI: ${data.result}`);
		}

		if (data.status === "1" && data.result) {
			return JSON.parse(data.result);
		}

		throw new Error("Invalid response from block explorer");
	} catch (error) {
		if (error instanceof Error) {
			throw error;
		}
		throw new Error("Failed to fetch ABI from block explorer");
	}
}

/**
 * Generate LootiScript wrapper from ABI
 */
function generateLootiScriptWrapper(abi: any[], contractAddress: string, contractName: string): string {
	const functions = abi.filter((item) => item.type === "function");
	const events = abi.filter((item) => item.type === "event");

	// Sanitize contract name for safe use in code (only alphanumeric and underscore)
	const safeContractName = contractName.replace(/[^a-zA-Z0-9_]/g, "_");
	if (!/^[a-zA-Z_]/.test(safeContractName)) {
		throw new Error(`Invalid contract name: must start with letter or underscore`);
	}

	// Escape contract address for safe use in string
	const safeAddress = JSON.stringify(contractAddress);

	let code = `// Auto-generated contract wrapper for ${safeContractName}
// Address: ${contractAddress}
// Generated by: l8b contract import

local ${safeContractName} = object
  address = ${safeAddress},
  abi = ${JSON.stringify(abi, null, 2)}
end

// Read functions (view/pure - no transaction)
`;

	// Generate read functions
	for (const func of functions.filter((f) => f.stateMutability === "view" || f.stateMutability === "pure")) {
		// Sanitize function name
		const safeFuncName = func.name.replace(/[^a-zA-Z0-9_]/g, "_");
		if (!safeFuncName || !/^[a-zA-Z_]/.test(safeFuncName)) {
			continue; // Skip invalid function names
		}
		const params = func.inputs.map((input: any, i: number) => {
			const paramName = input.name ? input.name.replace(/[^a-zA-Z0-9_]/g, "_") : `arg${i}`;
			return /^[a-zA-Z_]/.test(paramName) ? paramName : `arg${i}`;
		}).join(", ");

		// Escape function name for safe use in string
		const safeFuncNameStr = JSON.stringify(func.name);

		code += `
async function ${safeContractName}.${safeFuncName}(${params})
  return await evm.read(
    ${safeContractName}.address,
    ${safeContractName}.abi,
    ${safeFuncNameStr},
    {${func.inputs.map((_: any, i: number) => `arg${i + 1}`).join(", ")}}
  )
end
`;
	}

	code += `
// Write functions (state-changing - sends transaction)
`;

	// Generate write functions
	for (const func of functions.filter((f) => f.stateMutability !== "view" && f.stateMutability !== "pure")) {
		// Sanitize function name
		const safeFuncName = func.name.replace(/[^a-zA-Z0-9_]/g, "_");
		if (!safeFuncName || !/^[a-zA-Z_]/.test(safeFuncName)) {
			continue; // Skip invalid function names
		}
		const params = func.inputs.map((input: any, i: number) => {
			const paramName = input.name ? input.name.replace(/[^a-zA-Z0-9_]/g, "_") : `arg${i}`;
			return /^[a-zA-Z_]/.test(paramName) ? paramName : `arg${i}`;
		}).join(", ");

		// Escape function name for safe use in string
		const safeFuncNameStr = JSON.stringify(func.name);

		code += `
async function ${safeContractName}.${safeFuncName}(${params})
  return await evm.write(
    ${safeContractName}.address,
    ${safeContractName}.abi,
    ${safeFuncNameStr},
    {${func.inputs.map((_: any, i: number) => `arg${i + 1}`).join(", ")}}
  )
end
`;
	}

	if (events.length > 0) {
		// Escape event names for safe display
		const safeEventNames = events.map((e) => e.name.replace(/[^a-zA-Z0-9_]/g, "_")).filter(Boolean).join(", ");
		code += `
// Events
// Note: Event listening is not yet supported in LootiScript
// Available events: ${safeEventNames}
`;
	}

	code += `
return ${safeContractName}
`;

	return code;
}

/**
 * Import contract and generate wrapper
 */
export async function contractImport(options: ContractImportOptions): Promise<void> {
	const projectPath = options.projectPath || process.cwd();
	const contractsDir = path.join(projectPath, DEFAULT_DIRS.SCRIPTS, "contracts");

	// Ensure contracts directory exists
	await fs.ensureDir(contractsDir);

	console.log(pc.cyan(`\n  ðŸ“¦ Importing contract ${options.name} from ${options.chain}...\n`));

	try {
		// Fetch ABI
		console.log(pc.gray(`  Fetching ABI from ${CHAIN_CONFIG[options.chain.toLowerCase()].explorer}...`));
		const abi = await fetchABI(options.address, options.chain, options.apiKey);
		console.log(pc.green(`  âœ“ ABI fetched (${abi.length} items)\n`));

		// Generate wrapper
		console.log(pc.gray(`  Generating LootiScript wrapper...`));
		const wrapper = generateLootiScriptWrapper(abi, options.address, options.name);

		// Write to file
		const fileName = `${options.name.toLowerCase()}.loot`;
		const filePath = path.join(contractsDir, fileName);
		await fs.writeFile(filePath, wrapper);

		console.log(pc.green(`  âœ“ Wrapper generated: ${fileName}\n`));
		console.log(pc.gray("  Usage:"));
		console.log(pc.cyan(`    local ${options.name} = require("contracts/${options.name.toLowerCase()}")\n`));
	} catch (error) {
		console.error(pc.red("\nâœ— Failed to import contract:\n"));
		if (error instanceof Error) {
			console.error(pc.red(`  ${error.message}\n`));
		} else {
			console.error(pc.red(`  ${String(error)}\n`));
		}
		process.exit(1);
	}
}
