# L8B Game Engine - Cursor AI Agent Rules

## Project Overview

L8B (Looti Engine) is a TypeScript-based 2D game engine with a custom scripting language (LootiScript). The project is organized as a monorepo using Bun and Turbo.

## Package Manager

**CRITICAL: Always use Bun, never npm/yarn/pnpm**

- Installation: `bun install`
- Running scripts: `bun run <script>`
- Adding dependencies: `bun add <package>`
- For workspace packages: Use `workspace:*` protocol

## Code Style & Formatting

This project uses **Biome** for linting and formatting:

- **Indentation**: TABS (not spaces) - this is critical
- **Quotes**: Double quotes for JavaScript/TypeScript
- **Format code**: `bun run format`
- **Lint code**: `bun run lint`
- Always format code before committing

## Project Structure

```
l8b/
├── packages/
│   ├── core/          # Core APIs (sprites, screen, audio, input, time, map, palette, scene, assets)
│   ├── enggine/       # Runtime engine (VM, I/O, runtime orchestrator, stdlib)
│   ├── framework/     # CLI, compiler
│   ├── tooling/       # Language server, diagnostics, VSCode extension
│   └── lootiscript/   # LootiScript parser and language implementation
├── examples/          # Example projects and demos
├── docs/             # VitePress documentation (English)
└── apps/             # Applications
```

## TypeScript Conventions

- Use meaningful variable and function names
- Add JSDoc comments for public APIs and complex logic
- Prefer explicit types over inference for function signatures
- Use `interface` for object shapes, `type` for unions/intersections
- Organize imports: external packages → internal packages → relative imports
- Use `@l8b/` namespace for internal packages

## Monorepo Workflow

The project uses **Turbo** for build orchestration:

- Build all packages: `bun run build`
- Dev mode (all packages): `bun run dev`
- Type checking: `bun run check-types`
- Create new package: `bun run new`

## Build System

- Uses `tsup` for building TypeScript packages
- Base configuration: `tsup.config.base.ts` (shared across packages)
- Each package can override with its own `tsup.config.ts`
- Build output goes to `dist/` directory

## LootiScript Language

- Custom scripting language for the game engine
- Files use `.loot` extension
- Syntax similar to Lua/JavaScript but with game-specific features
- Compiled to bytecode for execution
- Language server provides autocompletion and diagnostics
- See `packages/lootiscript/` for parser/compiler implementation
- See `docs/fundamentals/looti-script-programming.md` for language documentation

## Core API Patterns

### Adding a New Core API Package

1. **Create package structure:**
   ```bash
   bun run new
   # Choose: core/<api-name>
   ```

2. **Package structure:**
   ```
   packages/core/<api-name>/
   ├── src/
   │   ├── index.ts          # Main export
   │   ├── types.ts          # TypeScript types
   │   └── ...               # Implementation
   ├── package.json
   ├── tsconfig.json
   └── tsup.config.ts
   ```

3. **Register in VM:**
   - Add to `packages/enggine/runtime/src/core/orchestrator.ts`
   - Register in `initializeVM()` method
   - Add to `GlobalAPI` type in `packages/enggine/vm/src/types/`

4. **Add API definitions:**
   - Create definition in `packages/tooling/language-server/src/api-definitions/<api-name>.ts`
   - Follow existing patterns (see `screen.ts`, `audio.ts`, etc.)

5. **Update documentation:**
   - Add README.md in package with full API documentation
   - Update `docs/fundamentals/api-reference.md`
   - Add examples in `examples/`

### Core API Naming Conventions

- **Global objects**: PascalCase (e.g., `Assets`, `Audio`, `Screen`)
- **Methods**: camelCase (e.g., `loadImage`, `playSound`)
- **Properties**: camelCase (e.g., `screen.width`, `system.time`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_FPS`)

### API Exposure Pattern

Core APIs are exposed to LootiScript via VM globals:

```typescript
// In orchestrator.ts
const global: GlobalAPI = {
  screen: this.screen.getInterface(),
  audio: this.audio.getInterface(),
  Assets: this.assets.getInterface(),
  // ...
};

this.vm = new L8BVM(meta, global, ...);
```

## VM Integration

- VM code is in `packages/enggine/vm/`
- Global API bindings are registered in VM context
- See `packages/enggine/runtime/src/core/orchestrator.ts` for registration
- VM uses bytecode execution for LootiScript

## Language Server Integration

- Code is in `packages/tooling/language-server/`
- API definitions drive autocompletion (see `src/api-definitions/`)
- Update diagnostics in `packages/tooling/diagnostics/`
- VSCode extension in `packages/tooling/vscode/`

## Testing

- Test files: `*.test.ts` or `*.spec.ts`
- Run tests: `bun run test`
- Watch mode: `bun run test:watch`
- Coverage: `bun run test:coverage`
- Use Vitest for all testing

## Documentation

- Uses VitePress for documentation (in `docs/`)
- All documentation is in English
- Dev server: `bun run docs:dev`
- Build docs: `bun run docs:build`
- API documentation should be in package README.md files
- See `docs/fundamentals/api-reference.md` for complete API reference

## Common Patterns

### Creating a Loader Object

Asset loading returns a loader object pattern:

```typescript
interface LoaderResult<T> {
  ready: 0 | 1;  // 0 = loading, 1 = ready
  data?: T;      // Available when ready === 1
}
```

### Scene Lifecycle

Scenes have lifecycle methods:
- `init()` - Called once when scene is registered
- `onEnter(params)` - Called when scene becomes active
- `onLeave()` - Called when scene is deactivated
- `update()` - Called every frame
- `draw()` - Called every frame

### Input State Objects

Input is exposed as global objects:
- `keyboard` - Keyboard state
- `mouse` - Mouse state
- `touch` - Touch state
- `gamepad` - Gamepad state

## File Naming Conventions

- **TypeScript files**: `kebab-case.ts` or `PascalCase.ts` for classes
- **LootiScript files**: `kebab-case.loot` or `camelCase.loot`
- **Test files**: `*.test.ts` or `*.spec.ts`
- **Config files**: `kebab-case.config.json`

## Import Patterns

```typescript
// External packages
import { something } from "external-package";

// Internal packages (use @l8b namespace)
import { something } from "@l8b/core/screen";
import { RuntimeOrchestrator } from "@l8b/runtime";

// Relative imports
import { helper } from "./helper";
```

## Error Handling

- Use descriptive error messages
- Include error codes (E7xxx for API errors)
- See `packages/error-tests/` for error test cases
- See `docs/quick-reference/error-cheatsheet.md` for error documentation

## Performance Considerations

- Core packages should be optimized for game loop (60 FPS)
- Use object pooling where appropriate
- Minimize allocations in hot paths
- Consider bytecode execution performance in VM

## Key Principles

1. **Type Safety**: Maintain strict TypeScript types throughout
2. **Documentation**: Keep code well-commented, especially for APIs
3. **Testing**: Write tests for new features and bug fixes
4. **Consistency**: Follow existing patterns in the codebase
5. **Performance**: Consider performance implications, especially for core and engine packages
6. **LootiScript First**: APIs should be designed for LootiScript usage, TypeScript is implementation detail

## When Making Changes

1. **Check existing patterns** - Look at similar code in the codebase
2. **Update documentation** - Keep README.md and docs/ up to date
3. **Add tests** - Write tests for new functionality
4. **Update API definitions** - If adding new API, update language server definitions
5. **Format code** - Always run `bun run format` before committing

## Getting Help

- Check existing similar code for patterns
- Review package README.md files for API documentation
- Review VitePress documentation in `docs/` for user-facing docs
- Look at examples in `examples/` directory for usage patterns
- See `AGENTS.md` and `DEVELOPMENT.md` for more context