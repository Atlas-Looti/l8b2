# Functions

Functions are reusable blocks of code that perform a specific task. In LootiScript, functions are first-class citizens, meaning they can be stored in variables, passed as arguments, and returned from other functions.

## Defining Functions

### Named Functions
The standard way to define a function is using the `function` keyword.

```lua
function greet(name)
  return "Hello, " .. name
end

print(greet("World"))  // Output: Hello, World
```

### Anonymous Functions
You can create functions without names and assign them to variables.

```lua
local add = function(a, b)
  return a + b
end

print(add(5, 3))  // Output: 8
```

### Arrow Functions
LootiScript supports a concise syntax for functions, similar to JavaScript's arrow functions.

```lua
// Basic arrow function
local multiply = (a, b) => a * b

// Single parameter (parentheses optional)
local square = x => x * x

// No parameters
local getTime = () => system.time

print(multiply(4, 5))  // Output: 20
```

## Parameters and Return Values

### Default Parameters
You can specify default values for parameters. If the caller doesn't provide a value, the default is used.

```lua
function sayHello(name, greeting = "Hello")
  print(greeting .. ", " .. name)
end

sayHello("Alice")          // Output: Hello, Alice
sayHello("Bob", "Hi")      // Output: Hi, Bob
```

### Return Values
Functions return `0` by default if no `return` statement is executed.

```lua
function doNothing()
  // No return statement
end

local result = doNothing()
print(result)  // Output: 0
```

### The `arguments` Object
Inside any function, you can access the `arguments` list to get all passed parameters. This is useful for functions that accept a variable number of arguments.

```lua
function sumAll()
  local total = 0
  for i = 0, #arguments - 1 do
    total += arguments[i]
  end
  return total
end

print(sumAll(1, 2, 3, 4))  // Output: 10
```

**Note:** The `arguments` list is 0-indexed, so the first argument is at `arguments[0]`, the second at `arguments[1]`, and so on. Use `#arguments` to get the total number of arguments.

## Higher-Order Functions

Since functions are values, you can pass them to other functions.

```lua
function apply(fn, value)
  return fn(value)
end

local double = x => x * 2

print(apply(double, 5))  // Output: 10
```

## Closures

Functions capture the scope in which they were defined. This allows for powerful patterns like closures.

```lua
function createCounter()
  local count = 0
  return function()
    count += 1
    return count
  end
end

local counter = createCounter()
print(counter())  // Output: 1
print(counter())  // Output: 2
```
