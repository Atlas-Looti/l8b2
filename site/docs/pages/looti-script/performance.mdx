# Performance & Optimization

LootiScript is built for speed, designed to run complex game logic at 60 FPS. However, as with any language, how you write your code matters. Here are some tips to keep your game running smoothly.

## How LootiScript Works

1.  **Compilation**: Your code is compiled into bytecode, a low-level format that is faster to execute than raw text.
2.  **Virtual Machine (VM)**: A custom VM executes this bytecode.
3.  **Inline Caching**: The VM "learns" the structure of your objects (e.g., `player.x`) and optimizes access to them, making property lookups nearly instant after the first few times.

## Optimization Tips

### 1. Use Local Variables
Accessing local variables is significantly faster than global variables. If you use a global value repeatedly in a loop, cache it in a local variable.

```lua
// ❌ Slower: Global lookup every iteration
for i = 1 to 1000 do
  player.x += 1
end

// ✅ Faster: Local cache
local p = player
for i = 1 to 1000 do
  p.x += 1
end
```

### 2. Avoid Creating Objects in `update`
Creating new objects (tables) every frame generates "garbage" that the system must clean up later (Garbage Collection). This can cause stuttering.

```lua
// ❌ Bad: Creates a new object every frame
function update(dt)
  local pos = {x = 10, y = 20} 
  move(pos)
end

// ✅ Good: Reuse object
local pos = {x = 0, y = 0}
function update(dt)
  pos.x = 10
  pos.y = 20
  move(pos)
end
```

### 3. Use `update` Efficiently
The `update` function runs 60 times a second. Keep it lean. Heavy calculations (like pathfinding) should be spread out or run less frequently using `every`.

```lua
// ❌ Heavy calculation every frame
function update(dt)
  calculatePathToPlayer() // Expensive!
end

// ✅ Spread out
every 500 milliseconds do
  calculatePathToPlayer()
end
```

### 4. Object Pooling
For objects that are created and destroyed frequently (like bullets or particles), use Object Pooling. Instead of deleting them, disable them and reuse them later.

```lua
// Simple Bullet Pool concept
local bullets = {}
local poolIndex = 1

function fireBullet()
  // Reuse existing bullet if available
  local b = bullets[poolIndex]
  if b == null then
    b = new Bullet()
    List.push(bullets, b)
  end
  
  b.reset()
  poolIndex += 1
end
```

## Profiling (Mental Check)

When writing code, ask yourself:
-   "Does this need to run *every single frame*?"
-   "Am I creating new tables/objects inside a loop?"
-   "Can I use a local variable here?"

By following these simple rules, you can write LootiScript code that scales to handle thousands of objects without dropping a frame.
