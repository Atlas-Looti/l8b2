<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scenes-demo</title>
    <style>
      @font-face {
        font-family: "BitCell";
        src: url("/fonts/BitCell.ttf") format("truetype");
        font-display: swap;
      }
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #0d1117;
        font-family: system-ui, sans-serif;
      }
      body {
        display: flex;
        align-items: stretch;
        justify-content: stretch;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: #000;
      }
      #game {
        image-rendering: pixelated; /* Ensure crisp pixels */
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <script type="module">
      // Production: Use bundled runtime
import { Runtime, Routine } from '/runtime.js';
      
      import main from '/compiled/main.js';
      import scenes_battle from '/compiled/scenes/battle.js';
      import scenes_home from '/compiled/scenes/home.js';
      import scenes_player from '/compiled/scenes/player.js';

      const canvas = document.getElementById('game');
      if (!canvas) throw new Error('Canvas element with id "game" not found');

      // Get window size for responsive canvas (if aspect is free)
      const getWindowSize = () => ({
        width: window.innerWidth,
        height: window.innerHeight,
      });

      // Helper to get device pixel ratio
      const getRatio = () => {
        const ctx = canvas.getContext('2d');
        const devicePixelRatio = window.devicePixelRatio || 1;
        const backingStoreRatio = ctx?.webkitBackingStorePixelRatio ||
          ctx?.mozBackingStorePixelRatio ||
          ctx?.msBackingStorePixelRatio ||
          ctx?.oBackingStorePixelRatio ||
          ctx?.backingStorePixelRatio || 1;
        return devicePixelRatio / backingStoreRatio;
      };

      // Initialize canvas size
      const isFreeAspect = true;
      let initialSize = isFreeAspect ? getWindowSize() : { width: 1920, height: 1080 };
      const ratio = getRatio();

      // Set canvas internal size with devicePixelRatio
      canvas.width = initialSize.width * ratio;
      canvas.height = initialSize.height * ratio;

      // Set canvas display size
      canvas.style.width = Math.round(initialSize.width) + 'px';
      canvas.style.height = Math.round(initialSize.height) + 'px';

      const resources = {"images":[],"maps":[],"sounds":[],"music":[],"assets":[]};

      const shouldLogLifecycleBrowser = true;
      const shouldLogLifecycleTerminal = false;
      const shouldLogCanvasBrowser = true;
      const shouldLogCanvasTerminal = false;
      const mirrorListenerLogs = true;
      const mirrorListenerErrors = true;
      
      // Terminal logging helper
      const sendTerminalLog = (entry) => {
        const payload = JSON.stringify({
          ...entry,
          timestamp: Date.now(),
        });

        if (navigator.sendBeacon) {
          const blob = new Blob([payload], { type: 'application/json' });
          navigator.sendBeacon('/__l8b/log', blob);
        } else {
          fetch('/__l8b/log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: payload,
            keepalive: true,
          }).catch(() => {});
        }
      };

      const logLifecycle = (message) => {
        if (!shouldLogLifecycleBrowser && !shouldLogLifecycleTerminal) return;
        if (shouldLogLifecycleBrowser) console.log(message);
        if (shouldLogLifecycleTerminal) {
          sendTerminalLog({ level: 'info', scope: 'runtime', message });
        }
      };

      const logCanvasSize = () => {
        if (!shouldLogCanvasBrowser && !shouldLogCanvasTerminal) return;
        const message = 'Canvas internal size: ' + canvas.width + 'x' + canvas.height + 
                       ', display size: ' + canvas.clientWidth + 'x' + canvas.clientHeight;
        if (shouldLogCanvasBrowser) console.log(message);
        if (shouldLogCanvasTerminal) {
          sendTerminalLog({ level: 'info', scope: 'runtime', message });
        }
      };

      const runtimeOptions = {
        canvas: canvas,
        width: canvas.width,
        height: canvas.height,
        url: '/',
        resources: resources,
        listener: {
          log: (message) => {
            console.log('[GAME]', message);
            if (mirrorListenerLogs) {
              sendTerminalLog({ level: 'info', scope: 'game', message: String(message) });
            }
          },
          reportError: (error) => {
            let errorMessage = '';
            if (error.code) errorMessage += '[' + error.code + '] ';
            errorMessage += error?.error || error?.message || error?.formatted || 'Runtime error';
            
            if (error.file) {
              errorMessage += '\n  at ' + error.file;
              if (error.line !== undefined) {
                errorMessage += ':' + error.line;
                if (error.column !== undefined) errorMessage += ':' + error.column;
              }
            }
            
            console.error('[GAME ERROR]', errorMessage);
            if (error.context) console.error(error.context);
            
            if (error.suggestions && error.suggestions.length > 0) {
              console.error('\nSuggestions:');
              for (let i = 0; i < error.suggestions.length; i++) {
                console.error('  â€¢ ' + error.suggestions[i]);
              }
            }
            
            if (mirrorListenerErrors) {
              sendTerminalLog({
                level: 'error',
                scope: 'game',
                message: errorMessage,
                details: Object.assign({}, error, { formatted: errorMessage }),
              });
            }
          },
          postMessage: (msg) => {
            // Compilation messages are handled during build
          },
        },
      };

      
      // Production: Use pre-compiled routines
      runtimeOptions.compiledRoutines = {
        'main': new Routine(0).import(main.routine),
          'scenes/battle': new Routine(0).import(scenes_battle.routine),
          'scenes/home': new Routine(0).import(scenes_home.routine),
          'scenes/player': new Routine(0).import(scenes_player.routine)
      };
      

      const runtime = new Runtime(runtimeOptions);

      // Handle window resize
      let resizeTimeout = null;
      const handleResize = () => {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (isFreeAspect) {
            const newSize = getWindowSize();
            const ratio = getRatio();
            
            canvas.width = newSize.width * ratio;
            canvas.height = newSize.height * ratio;
            canvas.style.width = Math.round(newSize.width) + 'px';
            canvas.style.height = Math.round(newSize.height) + 'px';
            
            if (runtime.screen) {
              runtime.screen.resize(canvas.width, canvas.height);
            }
          }
        }, 100);
      };

      // Start the game
      logLifecycle('Starting L8B Runtime...');
      try {
        await runtime.start();
        logLifecycle('Runtime started successfully!');
        logLifecycle('Game is running...');
        logCanvasSize();
      } catch (err) {
        console.error(err);
      }

      window.runtime = runtime;
      logLifecycle('Runtime available as window.runtime');
      window.addEventListener('resize', handleResize);
    </script>
  </body>
</html>